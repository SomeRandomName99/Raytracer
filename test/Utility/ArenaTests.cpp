#include "Arena.hpp"
#include "gtest/gtest.h"
#include <gtest/gtest.h>
#include <vector>
#include <future>

// Tests generated by cursor
namespace raytracer {
namespace utility {
namespace test {

class ArenaTest : public ::testing::Test {
protected:
  void SetUp() override {}
  void TearDown() override {}
};

// Simple test struct for testing
struct TestObject {
  int id;
  double value;
  std::string name;
  
  TestObject() : id(0), value(0.0), name("default") {}
  TestObject(int i, double v, const std::string& n) : id(i), value(v), name(n) {}
  
  bool operator==(const TestObject& other) const {
    return id == other.id && value == other.value && name == other.name;
  }
};

TEST_F(ArenaTest, BasicConstruction) {
  auto maxSize = MB(4);
  auto initialCapacity = 100;
  Arena<TestObject> arena(maxSize, initialCapacity); // Small arena for testing
  
  EXPECT_EQ(arena.size, 0);
  EXPECT_EQ(arena.capacity, initialCapacity);
  EXPECT_NE(arena.data, nullptr);
}

TEST_F(ArenaTest, AllocationFunctionality) {
  auto maxSize = KB(4);
  auto initialCapacity = 0;
  Arena<int> arena(maxSize, initialCapacity); // Small arena for testing
  
  // Test allocation within capacity
  size_t expectedCapacity = KB(4) / sizeof(int);
  EXPECT_TRUE(arena.allocate(expectedCapacity - 20)); 
  
  // Test allocation beyond capacity
  EXPECT_FALSE(arena.allocate(expectedCapacity));
}

TEST_F(ArenaTest, PushBackFunctionality) {
  Arena<TestObject> arena(MB(1));
  
  // Test initial state
  EXPECT_EQ(arena.size, 0);
  
  // Test pushBack
  TestObject obj1(1, 1.0, "first");
  arena.pushBack(obj1);
  EXPECT_EQ(arena.size, 1);
  
  // Test multiple pushBack
  TestObject obj2(2, 2.0, "second");
  arena.pushBack(obj2);
  EXPECT_EQ(arena.size, 2);
  
  // Test pushBack beyond capacity should not crash
  Arena<int> smallArena(sizeof(int) * 2); // Only 2 integers
  smallArena.pushBack(1);
  smallArena.pushBack(2);
  EXPECT_EQ(smallArena.size, 2);
  smallArena.pushBack(3); // Should not increase size
  EXPECT_EQ(smallArena.size, 2);
}

// Test popBack functionality
TEST_F(ArenaTest, PopBackFunctionality) {
  Arena<int> arena(KB(1));
  
  // Test popBack on empty arena
  arena.popBack();
  EXPECT_EQ(arena.size, 0);
  
  // Add elements and test popBack
  arena.pushBack(1);
  arena.pushBack(2);
  arena.pushBack(3);
  EXPECT_EQ(arena.size, 3);
  
  arena.popBack();
  EXPECT_EQ(arena.size, 2);
  
  arena.popBack();
  EXPECT_EQ(arena.size, 1);
  
  arena.popBack();
  EXPECT_EQ(arena.size, 0);
  
  // Test popBack on empty again
  arena.popBack();
  EXPECT_EQ(arena.size, 0);
}

TEST_F(ArenaTest, ClearFunctionality) {
  Arena<TestObject> arena(MB(1));
  
  arena.pushBack(TestObject(1, 1.0, "first"));
  arena.pushBack(TestObject(2, 2.0, "second"));
  arena.pushBack(TestObject(3, 3.0, "third"));
  EXPECT_EQ(arena.size, 3);
  
  // Clear arena
  arena.clear();
  EXPECT_EQ(arena.size, 0);
  
  // Data pointer should still be valid
  EXPECT_NE(arena.data, nullptr);
  
  // Should be able to add elements after clear
  arena.pushBack(TestObject(4, 4.0, "fourth"));
  EXPECT_EQ(arena.size, 1);
}

TEST_F(ArenaTest, SetPosBackFunctionality) {
  Arena<int> arena(KB(1));
  
  arena.pushBack(1);
  arena.pushBack(2);
  arena.pushBack(3);
  arena.pushBack(4);
  arena.pushBack(5);
  EXPECT_EQ(arena.size, 5);
  
  arena.setPosBack(3);
  EXPECT_EQ(arena.size, 3);
  
  // Test invalid index (should not change size)
  arena.setPosBack(10);
  EXPECT_EQ(arena.size, 3);
  
  // Set position back to 0
  arena.setPosBack(0);
  EXPECT_EQ(arena.size, 0);
}

TEST_F(ArenaTest, OperatorAccessFunctionality) {
  Arena<TestObject> arena(MB(1));
  
  arena.pushBack(TestObject(1, 1.0, "first"));
  arena.pushBack(TestObject(2, 2.0, "second"));
  arena.pushBack(TestObject(3, 3.0, "third"));
  
  // Test valid access
  auto obj1 = arena[0];
  EXPECT_EQ(obj1.id, 1);
  
  auto obj2 = arena[1];
  EXPECT_EQ(obj2.id, 2);
  
  // Test invalid access
  EXPECT_DEATH(arena[10], ".*");
  
  // Test const access
  const Arena<TestObject>& constArena = arena;
  auto constObj = constArena[0];
  EXPECT_EQ(constObj.id, 1);
}

TEST_F(ArenaTest, IteratorFunctionality) {
  Arena<TestObject> arena(MB(1));
  
  arena.pushBack(TestObject(1, 1.0, "first"));
  arena.pushBack(TestObject(2, 2.0, "second"));
  arena.pushBack(TestObject(3, 3.0, "third"));
  
  // Test range-based for loop
  int expectedId = 1;
  for (const auto& obj : arena) {
    EXPECT_EQ(obj.id, expectedId++);
  }
  
  // Test iterator access
  auto it = arena.begin();
  EXPECT_EQ(it->id, 1);
  ++it;
  EXPECT_EQ(it->id, 2);
  
  // Test const iterators
  const Arena<TestObject>& constArena = arena;
  auto constIt = constArena.begin();
  EXPECT_EQ(constIt->id, 1);
  
  // Test end iterator
  EXPECT_EQ(arena.end() - arena.begin(), 3);
}

TEST_F(ArenaTest, DifferentTypes) {
  Arena<int> intArena(KB(4));
  intArena.pushBack(42);
  intArena.pushBack(123);
  EXPECT_EQ(intArena.size, 2);
  auto intVal = intArena[0];
  EXPECT_EQ(intVal, 42);
  
  Arena<double> doubleArena(KB(4));
  doubleArena.pushBack(3.14159);
  EXPECT_EQ(doubleArena.size, 1);
  auto doubleVal = doubleArena[0];
  EXPECT_DOUBLE_EQ(doubleVal, 3.14159);
  
  Arena<std::string> stringArena(KB(4));
  stringArena.pushBack("hello world");
  EXPECT_EQ(stringArena.size, 1);
  auto stringVal = stringArena[0];
  EXPECT_EQ(stringVal, "hello world");
}

TEST_F(ArenaTest, MemoryLayoutAndDirectAccess) {
  Arena<TestObject> arena(MB(1));
  
  // Verify data pointer points to allocated memory
  EXPECT_NE(arena.data, nullptr);
  
  arena.pushBack(TestObject(1, 1.0, "first"));
  arena.pushBack(TestObject(2, 2.0, "second"));
  
  // Direct access through data pointer
  EXPECT_EQ(arena.data[0].id, 1);
  EXPECT_EQ(arena.data[1].id, 2);
  
  // Verify memory is contiguous
  TestObject* first = &arena.data[0];
  TestObject* second = &arena.data[1];
  EXPECT_EQ(second - first, 1);
}

TEST_F(ArenaTest, LargeCapacity) {
  auto maxSize = GB(1);
  auto initialCapacity = maxSize / sizeof(TestObject);
  Arena<TestObject> arena(maxSize, initialCapacity); // 1GB arena
  
  EXPECT_EQ(arena.size, 0);
  EXPECT_EQ(arena.capacity, initialCapacity);
  EXPECT_NE(arena.data, nullptr);
  
  // Should be able to add many elements
  for (int i = 0; i < 1000; ++i) {
    arena.pushBack(TestObject(i, i * 1.5, "test" + std::to_string(i)));
  }
  EXPECT_EQ(arena.size, 1000);
}

TEST_F(ArenaTest, ThreadSafeConstruction) {
  std::vector<std::future<bool>> futures;
  
  // Create multiple arenas in parallel threads
  for (int i = 0; i < 10; ++i) {
    futures.push_back(std::async(std::launch::async, []() {
      Arena<int> arena(MB(1));
      arena.pushBack(42);
      return arena.size == 1 && arena.data != nullptr;
    }));
  }
  
  // All threads should succeed
  for (auto& future : futures) {
    EXPECT_TRUE(future.get());
  }
}

TEST_F(ArenaTest, CapacityCalculations) {
  size_t expectedIntCapacity = KB(4) / sizeof(int);
  Arena<int> intArena(KB(4), expectedIntCapacity);
  EXPECT_EQ(intArena.capacity, expectedIntCapacity);
  
  size_t expectedDoubleCapacity = KB(8) / sizeof(double);
  Arena<double> doubleArena(KB(8), expectedDoubleCapacity);
  EXPECT_EQ(doubleArena.capacity, expectedDoubleCapacity);
  
  size_t expectedObjCapacity = MB(1) / sizeof(TestObject);
  Arena<TestObject> objArena(MB(1), expectedObjCapacity);
  EXPECT_EQ(objArena.capacity, expectedObjCapacity);
}

TEST_F(ArenaTest, EdgeCases) {
  // Test very small arena
  Arena<int> tinyArena(sizeof(int));
  EXPECT_EQ(tinyArena.capacity, 1);
  tinyArena.pushBack(42);
  EXPECT_EQ(tinyArena.size, 1);
  
  // Try to add beyond capacity
  tinyArena.pushBack(123);
  EXPECT_EQ(tinyArena.size, 1); // Should not increase
  
  // Test empty operations
  Arena<TestObject> emptyArena(MB(1));
  emptyArena.popBack(); // Should not crash
  emptyArena.clear(); // Should not crash
  emptyArena.setPosBack(5); // Should not crash
  EXPECT_EQ(emptyArena.size, 0);
}

} // namespace test
} // namespace utility 
} // namespace raytracer